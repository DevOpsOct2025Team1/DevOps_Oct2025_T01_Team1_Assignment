/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * API Gateway
 * API Gateway for the DevOps microservices app.
Provides authentication, user management, file management, and routing to backend services.
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  GetApiAdminListUsers200,
  GetApiAdminListUsersParams,
  InternalHandlersAbortMultipartUploadResponse,
  InternalHandlersAuthResponse,
  InternalHandlersCompleteMultipartUploadRequest,
  InternalHandlersDeleteFileResponse,
  InternalHandlersDeleteUserRequest,
  InternalHandlersDeleteUserResponse,
  InternalHandlersErrorResponse,
  InternalHandlersFileResponse,
  InternalHandlersGetFileResponse,
  InternalHandlersInitiateMultipartUploadRequest,
  InternalHandlersInitiateMultipartUploadResponse,
  InternalHandlersListFilesResponse,
  InternalHandlersLoginRequest,
  InternalHandlersSignUpRequest,
  InternalHandlersUploadPartResponse,
  PostApiFilesBody,
  PostApiFilesMultipartUploadIdPartPartNumberBody
} from './model';

import { customFetch } from '../orval-client';
type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Admin-only endpoint to create a new user account
 * @summary Create a new user
 */
export type postApiAdminCreateUserResponse200 = {
  data: InternalHandlersAuthResponse
  status: 200
}

export type postApiAdminCreateUserResponse400 = {
  data: InternalHandlersErrorResponse
  status: 400
}

export type postApiAdminCreateUserResponse401 = {
  data: InternalHandlersErrorResponse
  status: 401
}

export type postApiAdminCreateUserResponse403 = {
  data: InternalHandlersErrorResponse
  status: 403
}

export type postApiAdminCreateUserResponse500 = {
  data: InternalHandlersErrorResponse
  status: 500
}
    
export type postApiAdminCreateUserResponseSuccess = (postApiAdminCreateUserResponse200) & {
  headers: Headers;
};
export type postApiAdminCreateUserResponseError = (postApiAdminCreateUserResponse400 | postApiAdminCreateUserResponse401 | postApiAdminCreateUserResponse403 | postApiAdminCreateUserResponse500) & {
  headers: Headers;
};

export type postApiAdminCreateUserResponse = (postApiAdminCreateUserResponseSuccess | postApiAdminCreateUserResponseError)

export const getPostApiAdminCreateUserUrl = () => {


  

  return `/api/admin/create_user`
}

export const postApiAdminCreateUser = async (internalHandlersSignUpRequest: InternalHandlersSignUpRequest, options?: RequestInit): Promise<postApiAdminCreateUserResponse> => {
  
  return customFetch<postApiAdminCreateUserResponse>(getPostApiAdminCreateUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      internalHandlersSignUpRequest,)
  }
);}




export const getPostApiAdminCreateUserMutationOptions = <TError = InternalHandlersErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAdminCreateUser>>, TError,{data: InternalHandlersSignUpRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postApiAdminCreateUser>>, TError,{data: InternalHandlersSignUpRequest}, TContext> => {

const mutationKey = ['postApiAdminCreateUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiAdminCreateUser>>, {data: InternalHandlersSignUpRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiAdminCreateUser(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiAdminCreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof postApiAdminCreateUser>>>
    export type PostApiAdminCreateUserMutationBody = InternalHandlersSignUpRequest
    export type PostApiAdminCreateUserMutationError = InternalHandlersErrorResponse

    /**
 * @summary Create a new user
 */
export const usePostApiAdminCreateUser = <TError = InternalHandlersErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAdminCreateUser>>, TError,{data: InternalHandlersSignUpRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiAdminCreateUser>>,
        TError,
        {data: InternalHandlersSignUpRequest},
        TContext
      > => {
      return useMutation(getPostApiAdminCreateUserMutationOptions(options), queryClient);
    }
    
/**
 * Admin-only endpoint to delete a user account. Cannot delete own account or other admin accounts.
 * @summary Delete a user
 */
export type deleteApiAdminDeleteUserResponse200 = {
  data: InternalHandlersDeleteUserResponse
  status: 200
}

export type deleteApiAdminDeleteUserResponse400 = {
  data: InternalHandlersErrorResponse
  status: 400
}

export type deleteApiAdminDeleteUserResponse401 = {
  data: InternalHandlersErrorResponse
  status: 401
}

export type deleteApiAdminDeleteUserResponse403 = {
  data: InternalHandlersErrorResponse
  status: 403
}

export type deleteApiAdminDeleteUserResponse404 = {
  data: InternalHandlersErrorResponse
  status: 404
}

export type deleteApiAdminDeleteUserResponse500 = {
  data: InternalHandlersErrorResponse
  status: 500
}
    
export type deleteApiAdminDeleteUserResponseSuccess = (deleteApiAdminDeleteUserResponse200) & {
  headers: Headers;
};
export type deleteApiAdminDeleteUserResponseError = (deleteApiAdminDeleteUserResponse400 | deleteApiAdminDeleteUserResponse401 | deleteApiAdminDeleteUserResponse403 | deleteApiAdminDeleteUserResponse404 | deleteApiAdminDeleteUserResponse500) & {
  headers: Headers;
};

export type deleteApiAdminDeleteUserResponse = (deleteApiAdminDeleteUserResponseSuccess | deleteApiAdminDeleteUserResponseError)

export const getDeleteApiAdminDeleteUserUrl = () => {


  

  return `/api/admin/delete_user`
}

export const deleteApiAdminDeleteUser = async (internalHandlersDeleteUserRequest: InternalHandlersDeleteUserRequest, options?: RequestInit): Promise<deleteApiAdminDeleteUserResponse> => {
  
  return customFetch<deleteApiAdminDeleteUserResponse>(getDeleteApiAdminDeleteUserUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      internalHandlersDeleteUserRequest,)
  }
);}




export const getDeleteApiAdminDeleteUserMutationOptions = <TError = InternalHandlersErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiAdminDeleteUser>>, TError,{data: InternalHandlersDeleteUserRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteApiAdminDeleteUser>>, TError,{data: InternalHandlersDeleteUserRequest}, TContext> => {

const mutationKey = ['deleteApiAdminDeleteUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApiAdminDeleteUser>>, {data: InternalHandlersDeleteUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  deleteApiAdminDeleteUser(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteApiAdminDeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApiAdminDeleteUser>>>
    export type DeleteApiAdminDeleteUserMutationBody = InternalHandlersDeleteUserRequest
    export type DeleteApiAdminDeleteUserMutationError = InternalHandlersErrorResponse

    /**
 * @summary Delete a user
 */
export const useDeleteApiAdminDeleteUser = <TError = InternalHandlersErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiAdminDeleteUser>>, TError,{data: InternalHandlersDeleteUserRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteApiAdminDeleteUser>>,
        TError,
        {data: InternalHandlersDeleteUserRequest},
        TContext
      > => {
      return useMutation(getDeleteApiAdminDeleteUserMutationOptions(options), queryClient);
    }
    
/**
 * Admin-only endpoint to list all users with optional role filter and username search
 * @summary List all users
 */
export type getApiAdminListUsersResponse200 = {
  data: GetApiAdminListUsers200
  status: 200
}

export type getApiAdminListUsersResponse400 = {
  data: InternalHandlersErrorResponse
  status: 400
}

export type getApiAdminListUsersResponse401 = {
  data: InternalHandlersErrorResponse
  status: 401
}

export type getApiAdminListUsersResponse500 = {
  data: InternalHandlersErrorResponse
  status: 500
}
    
export type getApiAdminListUsersResponseSuccess = (getApiAdminListUsersResponse200) & {
  headers: Headers;
};
export type getApiAdminListUsersResponseError = (getApiAdminListUsersResponse400 | getApiAdminListUsersResponse401 | getApiAdminListUsersResponse500) & {
  headers: Headers;
};

export type getApiAdminListUsersResponse = (getApiAdminListUsersResponseSuccess | getApiAdminListUsersResponseError)

export const getGetApiAdminListUsersUrl = (params?: GetApiAdminListUsersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/admin/list_users?${stringifiedParams}` : `/api/admin/list_users`
}

export const getApiAdminListUsers = async (params?: GetApiAdminListUsersParams, options?: RequestInit): Promise<getApiAdminListUsersResponse> => {
  
  return customFetch<getApiAdminListUsersResponse>(getGetApiAdminListUsersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetApiAdminListUsersQueryKey = (params?: GetApiAdminListUsersParams,) => {
    return [
    `/api/admin/list_users`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetApiAdminListUsersQueryOptions = <TData = Awaited<ReturnType<typeof getApiAdminListUsers>>, TError = InternalHandlersErrorResponse>(params?: GetApiAdminListUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAdminListUsers>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiAdminListUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiAdminListUsers>>> = ({ signal }) => getApiAdminListUsers(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiAdminListUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiAdminListUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getApiAdminListUsers>>>
export type GetApiAdminListUsersQueryError = InternalHandlersErrorResponse


export function useGetApiAdminListUsers<TData = Awaited<ReturnType<typeof getApiAdminListUsers>>, TError = InternalHandlersErrorResponse>(
 params: undefined |  GetApiAdminListUsersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAdminListUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiAdminListUsers>>,
          TError,
          Awaited<ReturnType<typeof getApiAdminListUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiAdminListUsers<TData = Awaited<ReturnType<typeof getApiAdminListUsers>>, TError = InternalHandlersErrorResponse>(
 params?: GetApiAdminListUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAdminListUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiAdminListUsers>>,
          TError,
          Awaited<ReturnType<typeof getApiAdminListUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiAdminListUsers<TData = Awaited<ReturnType<typeof getApiAdminListUsers>>, TError = InternalHandlersErrorResponse>(
 params?: GetApiAdminListUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAdminListUsers>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List all users
 */

export function useGetApiAdminListUsers<TData = Awaited<ReturnType<typeof getApiAdminListUsers>>, TError = InternalHandlersErrorResponse>(
 params?: GetApiAdminListUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiAdminListUsers>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiAdminListUsersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Retrieve a list of all files uploaded by the authenticated user
 * @summary List all files for the authenticated user
 */
export type getApiFilesResponse200 = {
  data: InternalHandlersListFilesResponse
  status: 200
}

export type getApiFilesResponse401 = {
  data: InternalHandlersErrorResponse
  status: 401
}

export type getApiFilesResponse500 = {
  data: InternalHandlersErrorResponse
  status: 500
}
    
export type getApiFilesResponseSuccess = (getApiFilesResponse200) & {
  headers: Headers;
};
export type getApiFilesResponseError = (getApiFilesResponse401 | getApiFilesResponse500) & {
  headers: Headers;
};

export type getApiFilesResponse = (getApiFilesResponseSuccess | getApiFilesResponseError)

export const getGetApiFilesUrl = () => {


  

  return `/api/files`
}

export const getApiFiles = async ( options?: RequestInit): Promise<getApiFilesResponse> => {
  
  return customFetch<getApiFilesResponse>(getGetApiFilesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetApiFilesQueryKey = () => {
    return [
    `/api/files`
    ] as const;
    }

    
export const getGetApiFilesQueryOptions = <TData = Awaited<ReturnType<typeof getApiFiles>>, TError = InternalHandlersErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFiles>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiFilesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiFiles>>> = ({ signal }) => getApiFiles({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiFiles>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiFilesQueryResult = NonNullable<Awaited<ReturnType<typeof getApiFiles>>>
export type GetApiFilesQueryError = InternalHandlersErrorResponse


export function useGetApiFiles<TData = Awaited<ReturnType<typeof getApiFiles>>, TError = InternalHandlersErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFiles>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiFiles>>,
          TError,
          Awaited<ReturnType<typeof getApiFiles>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiFiles<TData = Awaited<ReturnType<typeof getApiFiles>>, TError = InternalHandlersErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFiles>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiFiles>>,
          TError,
          Awaited<ReturnType<typeof getApiFiles>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiFiles<TData = Awaited<ReturnType<typeof getApiFiles>>, TError = InternalHandlersErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFiles>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List all files for the authenticated user
 */

export function useGetApiFiles<TData = Awaited<ReturnType<typeof getApiFiles>>, TError = InternalHandlersErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFiles>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiFilesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Upload a file to S3 and save metadata for the authenticated user
 * @summary Upload a file
 */
export type postApiFilesResponse200 = {
  data: InternalHandlersFileResponse
  status: 200
}

export type postApiFilesResponse400 = {
  data: InternalHandlersErrorResponse
  status: 400
}

export type postApiFilesResponse401 = {
  data: InternalHandlersErrorResponse
  status: 401
}

export type postApiFilesResponse429 = {
  data: InternalHandlersErrorResponse
  status: 429
}

export type postApiFilesResponse500 = {
  data: InternalHandlersErrorResponse
  status: 500
}
    
export type postApiFilesResponseSuccess = (postApiFilesResponse200) & {
  headers: Headers;
};
export type postApiFilesResponseError = (postApiFilesResponse400 | postApiFilesResponse401 | postApiFilesResponse429 | postApiFilesResponse500) & {
  headers: Headers;
};

export type postApiFilesResponse = (postApiFilesResponseSuccess | postApiFilesResponseError)

export const getPostApiFilesUrl = () => {


  

  return `/api/files`
}

export const postApiFiles = async (postApiFilesBody: PostApiFilesBody, options?: RequestInit): Promise<postApiFilesResponse> => {
    const formData = new FormData();
formData.append(`file`, postApiFilesBody.file);

  return customFetch<postApiFilesResponse>(getPostApiFilesUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getPostApiFilesMutationOptions = <TError = InternalHandlersErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiFiles>>, TError,{data: PostApiFilesBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postApiFiles>>, TError,{data: PostApiFilesBody}, TContext> => {

const mutationKey = ['postApiFiles'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiFiles>>, {data: PostApiFilesBody}> = (props) => {
          const {data} = props ?? {};

          return  postApiFiles(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiFilesMutationResult = NonNullable<Awaited<ReturnType<typeof postApiFiles>>>
    export type PostApiFilesMutationBody = PostApiFilesBody
    export type PostApiFilesMutationError = InternalHandlersErrorResponse

    /**
 * @summary Upload a file
 */
export const usePostApiFiles = <TError = InternalHandlersErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiFiles>>, TError,{data: PostApiFilesBody}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiFiles>>,
        TError,
        {data: PostApiFilesBody},
        TContext
      > => {
      return useMutation(getPostApiFilesMutationOptions(options), queryClient);
    }
    
/**
 * Start a new multipart upload session for large files
 * @summary Initiate a multipart upload
 */
export type postApiFilesMultipartInitiateResponse200 = {
  data: InternalHandlersInitiateMultipartUploadResponse
  status: 200
}

export type postApiFilesMultipartInitiateResponse400 = {
  data: InternalHandlersErrorResponse
  status: 400
}

export type postApiFilesMultipartInitiateResponse401 = {
  data: InternalHandlersErrorResponse
  status: 401
}

export type postApiFilesMultipartInitiateResponse500 = {
  data: InternalHandlersErrorResponse
  status: 500
}
    
export type postApiFilesMultipartInitiateResponseSuccess = (postApiFilesMultipartInitiateResponse200) & {
  headers: Headers;
};
export type postApiFilesMultipartInitiateResponseError = (postApiFilesMultipartInitiateResponse400 | postApiFilesMultipartInitiateResponse401 | postApiFilesMultipartInitiateResponse500) & {
  headers: Headers;
};

export type postApiFilesMultipartInitiateResponse = (postApiFilesMultipartInitiateResponseSuccess | postApiFilesMultipartInitiateResponseError)

export const getPostApiFilesMultipartInitiateUrl = () => {


  

  return `/api/files/multipart/initiate`
}

export const postApiFilesMultipartInitiate = async (internalHandlersInitiateMultipartUploadRequest: InternalHandlersInitiateMultipartUploadRequest, options?: RequestInit): Promise<postApiFilesMultipartInitiateResponse> => {
  
  return customFetch<postApiFilesMultipartInitiateResponse>(getPostApiFilesMultipartInitiateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      internalHandlersInitiateMultipartUploadRequest,)
  }
);}




export const getPostApiFilesMultipartInitiateMutationOptions = <TError = InternalHandlersErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiFilesMultipartInitiate>>, TError,{data: InternalHandlersInitiateMultipartUploadRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postApiFilesMultipartInitiate>>, TError,{data: InternalHandlersInitiateMultipartUploadRequest}, TContext> => {

const mutationKey = ['postApiFilesMultipartInitiate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiFilesMultipartInitiate>>, {data: InternalHandlersInitiateMultipartUploadRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiFilesMultipartInitiate(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiFilesMultipartInitiateMutationResult = NonNullable<Awaited<ReturnType<typeof postApiFilesMultipartInitiate>>>
    export type PostApiFilesMultipartInitiateMutationBody = InternalHandlersInitiateMultipartUploadRequest
    export type PostApiFilesMultipartInitiateMutationError = InternalHandlersErrorResponse

    /**
 * @summary Initiate a multipart upload
 */
export const usePostApiFilesMultipartInitiate = <TError = InternalHandlersErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiFilesMultipartInitiate>>, TError,{data: InternalHandlersInitiateMultipartUploadRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiFilesMultipartInitiate>>,
        TError,
        {data: InternalHandlersInitiateMultipartUploadRequest},
        TContext
      > => {
      return useMutation(getPostApiFilesMultipartInitiateMutationOptions(options), queryClient);
    }
    
/**
 * Cancel an in-progress multipart upload and clean up resources
 * @summary Abort a multipart upload
 */
export type deleteApiFilesMultipartUploadIdResponse200 = {
  data: InternalHandlersAbortMultipartUploadResponse
  status: 200
}

export type deleteApiFilesMultipartUploadIdResponse401 = {
  data: InternalHandlersErrorResponse
  status: 401
}

export type deleteApiFilesMultipartUploadIdResponse500 = {
  data: InternalHandlersErrorResponse
  status: 500
}
    
export type deleteApiFilesMultipartUploadIdResponseSuccess = (deleteApiFilesMultipartUploadIdResponse200) & {
  headers: Headers;
};
export type deleteApiFilesMultipartUploadIdResponseError = (deleteApiFilesMultipartUploadIdResponse401 | deleteApiFilesMultipartUploadIdResponse500) & {
  headers: Headers;
};

export type deleteApiFilesMultipartUploadIdResponse = (deleteApiFilesMultipartUploadIdResponseSuccess | deleteApiFilesMultipartUploadIdResponseError)

export const getDeleteApiFilesMultipartUploadIdUrl = (uploadId: string,) => {


  

  return `/api/files/multipart/${uploadId}`
}

export const deleteApiFilesMultipartUploadId = async (uploadId: string, options?: RequestInit): Promise<deleteApiFilesMultipartUploadIdResponse> => {
  
  return customFetch<deleteApiFilesMultipartUploadIdResponse>(getDeleteApiFilesMultipartUploadIdUrl(uploadId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteApiFilesMultipartUploadIdMutationOptions = <TError = InternalHandlersErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiFilesMultipartUploadId>>, TError,{uploadId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteApiFilesMultipartUploadId>>, TError,{uploadId: string}, TContext> => {

const mutationKey = ['deleteApiFilesMultipartUploadId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApiFilesMultipartUploadId>>, {uploadId: string}> = (props) => {
          const {uploadId} = props ?? {};

          return  deleteApiFilesMultipartUploadId(uploadId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteApiFilesMultipartUploadIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApiFilesMultipartUploadId>>>
    
    export type DeleteApiFilesMultipartUploadIdMutationError = InternalHandlersErrorResponse

    /**
 * @summary Abort a multipart upload
 */
export const useDeleteApiFilesMultipartUploadId = <TError = InternalHandlersErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiFilesMultipartUploadId>>, TError,{uploadId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteApiFilesMultipartUploadId>>,
        TError,
        {uploadId: string},
        TContext
      > => {
      return useMutation(getDeleteApiFilesMultipartUploadIdMutationOptions(options), queryClient);
    }
    
/**
 * Finalize a multipart upload by providing all part ETags
 * @summary Complete a multipart upload
 */
export type postApiFilesMultipartUploadIdCompleteResponse200 = {
  data: InternalHandlersFileResponse
  status: 200
}

export type postApiFilesMultipartUploadIdCompleteResponse400 = {
  data: InternalHandlersErrorResponse
  status: 400
}

export type postApiFilesMultipartUploadIdCompleteResponse401 = {
  data: InternalHandlersErrorResponse
  status: 401
}

export type postApiFilesMultipartUploadIdCompleteResponse404 = {
  data: InternalHandlersErrorResponse
  status: 404
}

export type postApiFilesMultipartUploadIdCompleteResponse500 = {
  data: InternalHandlersErrorResponse
  status: 500
}
    
export type postApiFilesMultipartUploadIdCompleteResponseSuccess = (postApiFilesMultipartUploadIdCompleteResponse200) & {
  headers: Headers;
};
export type postApiFilesMultipartUploadIdCompleteResponseError = (postApiFilesMultipartUploadIdCompleteResponse400 | postApiFilesMultipartUploadIdCompleteResponse401 | postApiFilesMultipartUploadIdCompleteResponse404 | postApiFilesMultipartUploadIdCompleteResponse500) & {
  headers: Headers;
};

export type postApiFilesMultipartUploadIdCompleteResponse = (postApiFilesMultipartUploadIdCompleteResponseSuccess | postApiFilesMultipartUploadIdCompleteResponseError)

export const getPostApiFilesMultipartUploadIdCompleteUrl = (uploadId: string,) => {


  

  return `/api/files/multipart/${uploadId}/complete`
}

export const postApiFilesMultipartUploadIdComplete = async (uploadId: string,
    internalHandlersCompleteMultipartUploadRequest: InternalHandlersCompleteMultipartUploadRequest, options?: RequestInit): Promise<postApiFilesMultipartUploadIdCompleteResponse> => {
  
  return customFetch<postApiFilesMultipartUploadIdCompleteResponse>(getPostApiFilesMultipartUploadIdCompleteUrl(uploadId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      internalHandlersCompleteMultipartUploadRequest,)
  }
);}




export const getPostApiFilesMultipartUploadIdCompleteMutationOptions = <TError = InternalHandlersErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiFilesMultipartUploadIdComplete>>, TError,{uploadId: string;data: InternalHandlersCompleteMultipartUploadRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postApiFilesMultipartUploadIdComplete>>, TError,{uploadId: string;data: InternalHandlersCompleteMultipartUploadRequest}, TContext> => {

const mutationKey = ['postApiFilesMultipartUploadIdComplete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiFilesMultipartUploadIdComplete>>, {uploadId: string;data: InternalHandlersCompleteMultipartUploadRequest}> = (props) => {
          const {uploadId,data} = props ?? {};

          return  postApiFilesMultipartUploadIdComplete(uploadId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiFilesMultipartUploadIdCompleteMutationResult = NonNullable<Awaited<ReturnType<typeof postApiFilesMultipartUploadIdComplete>>>
    export type PostApiFilesMultipartUploadIdCompleteMutationBody = InternalHandlersCompleteMultipartUploadRequest
    export type PostApiFilesMultipartUploadIdCompleteMutationError = InternalHandlersErrorResponse

    /**
 * @summary Complete a multipart upload
 */
export const usePostApiFilesMultipartUploadIdComplete = <TError = InternalHandlersErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiFilesMultipartUploadIdComplete>>, TError,{uploadId: string;data: InternalHandlersCompleteMultipartUploadRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiFilesMultipartUploadIdComplete>>,
        TError,
        {uploadId: string;data: InternalHandlersCompleteMultipartUploadRequest},
        TContext
      > => {
      return useMutation(getPostApiFilesMultipartUploadIdCompleteMutationOptions(options), queryClient);
    }
    
/**
 * Upload a single chunk of a file as part of a multipart upload
 * @summary Upload a part of a multipart upload
 */
export type postApiFilesMultipartUploadIdPartPartNumberResponse200 = {
  data: InternalHandlersUploadPartResponse
  status: 200
}

export type postApiFilesMultipartUploadIdPartPartNumberResponse400 = {
  data: InternalHandlersErrorResponse
  status: 400
}

export type postApiFilesMultipartUploadIdPartPartNumberResponse401 = {
  data: InternalHandlersErrorResponse
  status: 401
}

export type postApiFilesMultipartUploadIdPartPartNumberResponse500 = {
  data: InternalHandlersErrorResponse
  status: 500
}
    
export type postApiFilesMultipartUploadIdPartPartNumberResponseSuccess = (postApiFilesMultipartUploadIdPartPartNumberResponse200) & {
  headers: Headers;
};
export type postApiFilesMultipartUploadIdPartPartNumberResponseError = (postApiFilesMultipartUploadIdPartPartNumberResponse400 | postApiFilesMultipartUploadIdPartPartNumberResponse401 | postApiFilesMultipartUploadIdPartPartNumberResponse500) & {
  headers: Headers;
};

export type postApiFilesMultipartUploadIdPartPartNumberResponse = (postApiFilesMultipartUploadIdPartPartNumberResponseSuccess | postApiFilesMultipartUploadIdPartPartNumberResponseError)

export const getPostApiFilesMultipartUploadIdPartPartNumberUrl = (uploadId: string,
    partNumber: number,) => {


  

  return `/api/files/multipart/${uploadId}/part/${partNumber}`
}

export const postApiFilesMultipartUploadIdPartPartNumber = async (uploadId: string,
    partNumber: number,
    postApiFilesMultipartUploadIdPartPartNumberBody: PostApiFilesMultipartUploadIdPartPartNumberBody, options?: RequestInit): Promise<postApiFilesMultipartUploadIdPartPartNumberResponse> => {
    const formData = new FormData();
formData.append(`chunk`, postApiFilesMultipartUploadIdPartPartNumberBody.chunk);

  return customFetch<postApiFilesMultipartUploadIdPartPartNumberResponse>(getPostApiFilesMultipartUploadIdPartPartNumberUrl(uploadId,partNumber),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}




export const getPostApiFilesMultipartUploadIdPartPartNumberMutationOptions = <TError = InternalHandlersErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiFilesMultipartUploadIdPartPartNumber>>, TError,{uploadId: string;partNumber: number;data: PostApiFilesMultipartUploadIdPartPartNumberBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postApiFilesMultipartUploadIdPartPartNumber>>, TError,{uploadId: string;partNumber: number;data: PostApiFilesMultipartUploadIdPartPartNumberBody}, TContext> => {

const mutationKey = ['postApiFilesMultipartUploadIdPartPartNumber'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiFilesMultipartUploadIdPartPartNumber>>, {uploadId: string;partNumber: number;data: PostApiFilesMultipartUploadIdPartPartNumberBody}> = (props) => {
          const {uploadId,partNumber,data} = props ?? {};

          return  postApiFilesMultipartUploadIdPartPartNumber(uploadId,partNumber,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiFilesMultipartUploadIdPartPartNumberMutationResult = NonNullable<Awaited<ReturnType<typeof postApiFilesMultipartUploadIdPartPartNumber>>>
    export type PostApiFilesMultipartUploadIdPartPartNumberMutationBody = PostApiFilesMultipartUploadIdPartPartNumberBody
    export type PostApiFilesMultipartUploadIdPartPartNumberMutationError = InternalHandlersErrorResponse

    /**
 * @summary Upload a part of a multipart upload
 */
export const usePostApiFilesMultipartUploadIdPartPartNumber = <TError = InternalHandlersErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiFilesMultipartUploadIdPartPartNumber>>, TError,{uploadId: string;partNumber: number;data: PostApiFilesMultipartUploadIdPartPartNumberBody}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiFilesMultipartUploadIdPartPartNumber>>,
        TError,
        {uploadId: string;partNumber: number;data: PostApiFilesMultipartUploadIdPartPartNumberBody},
        TContext
      > => {
      return useMutation(getPostApiFilesMultipartUploadIdPartPartNumberMutationOptions(options), queryClient);
    }
    
/**
 * Retrieve metadata for a specific file by ID
 * @summary Get file metadata
 */
export type getApiFilesIdResponse200 = {
  data: InternalHandlersGetFileResponse
  status: 200
}

export type getApiFilesIdResponse400 = {
  data: InternalHandlersErrorResponse
  status: 400
}

export type getApiFilesIdResponse401 = {
  data: InternalHandlersErrorResponse
  status: 401
}

export type getApiFilesIdResponse404 = {
  data: InternalHandlersErrorResponse
  status: 404
}

export type getApiFilesIdResponse500 = {
  data: InternalHandlersErrorResponse
  status: 500
}
    
export type getApiFilesIdResponseSuccess = (getApiFilesIdResponse200) & {
  headers: Headers;
};
export type getApiFilesIdResponseError = (getApiFilesIdResponse400 | getApiFilesIdResponse401 | getApiFilesIdResponse404 | getApiFilesIdResponse500) & {
  headers: Headers;
};

export type getApiFilesIdResponse = (getApiFilesIdResponseSuccess | getApiFilesIdResponseError)

export const getGetApiFilesIdUrl = (id: string,) => {


  

  return `/api/files/${id}`
}

export const getApiFilesId = async (id: string, options?: RequestInit): Promise<getApiFilesIdResponse> => {
  
  return customFetch<getApiFilesIdResponse>(getGetApiFilesIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetApiFilesIdQueryKey = (id: string,) => {
    return [
    `/api/files/${id}`
    ] as const;
    }

    
export const getGetApiFilesIdQueryOptions = <TData = Awaited<ReturnType<typeof getApiFilesId>>, TError = InternalHandlersErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiFilesIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiFilesId>>> = ({ signal }) => getApiFilesId(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiFilesId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiFilesIdQueryResult = NonNullable<Awaited<ReturnType<typeof getApiFilesId>>>
export type GetApiFilesIdQueryError = InternalHandlersErrorResponse


export function useGetApiFilesId<TData = Awaited<ReturnType<typeof getApiFilesId>>, TError = InternalHandlersErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiFilesId>>,
          TError,
          Awaited<ReturnType<typeof getApiFilesId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiFilesId<TData = Awaited<ReturnType<typeof getApiFilesId>>, TError = InternalHandlersErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiFilesId>>,
          TError,
          Awaited<ReturnType<typeof getApiFilesId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiFilesId<TData = Awaited<ReturnType<typeof getApiFilesId>>, TError = InternalHandlersErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get file metadata
 */

export function useGetApiFilesId<TData = Awaited<ReturnType<typeof getApiFilesId>>, TError = InternalHandlersErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiFilesIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Delete a file by ID (must be owned by the authenticated user)
 * @summary Delete a file
 */
export type deleteApiFilesIdResponse200 = {
  data: InternalHandlersDeleteFileResponse
  status: 200
}

export type deleteApiFilesIdResponse400 = {
  data: InternalHandlersErrorResponse
  status: 400
}

export type deleteApiFilesIdResponse401 = {
  data: InternalHandlersErrorResponse
  status: 401
}

export type deleteApiFilesIdResponse404 = {
  data: InternalHandlersErrorResponse
  status: 404
}

export type deleteApiFilesIdResponse500 = {
  data: InternalHandlersErrorResponse
  status: 500
}
    
export type deleteApiFilesIdResponseSuccess = (deleteApiFilesIdResponse200) & {
  headers: Headers;
};
export type deleteApiFilesIdResponseError = (deleteApiFilesIdResponse400 | deleteApiFilesIdResponse401 | deleteApiFilesIdResponse404 | deleteApiFilesIdResponse500) & {
  headers: Headers;
};

export type deleteApiFilesIdResponse = (deleteApiFilesIdResponseSuccess | deleteApiFilesIdResponseError)

export const getDeleteApiFilesIdUrl = (id: string,) => {


  

  return `/api/files/${id}`
}

export const deleteApiFilesId = async (id: string, options?: RequestInit): Promise<deleteApiFilesIdResponse> => {
  
  return customFetch<deleteApiFilesIdResponse>(getDeleteApiFilesIdUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteApiFilesIdMutationOptions = <TError = InternalHandlersErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiFilesId>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteApiFilesId>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteApiFilesId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApiFilesId>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteApiFilesId(id,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteApiFilesIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApiFilesId>>>
    
    export type DeleteApiFilesIdMutationError = InternalHandlersErrorResponse

    /**
 * @summary Delete a file
 */
export const useDeleteApiFilesId = <TError = InternalHandlersErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiFilesId>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteApiFilesId>>,
        TError,
        {id: string},
        TContext
      > => {
      return useMutation(getDeleteApiFilesIdMutationOptions(options), queryClient);
    }
    
/**
 * Download a file by ID (must be owned by the authenticated user)
 * @summary Download a file
 */
export type getApiFilesIdDownloadResponse200 = {
  data: Blob
  status: 200
}

export type getApiFilesIdDownloadResponse400 = {
  data: Blob
  status: 400
}

export type getApiFilesIdDownloadResponse401 = {
  data: Blob
  status: 401
}

export type getApiFilesIdDownloadResponse404 = {
  data: Blob
  status: 404
}

export type getApiFilesIdDownloadResponse500 = {
  data: Blob
  status: 500
}
    
export type getApiFilesIdDownloadResponseSuccess = (getApiFilesIdDownloadResponse200) & {
  headers: Headers;
};
export type getApiFilesIdDownloadResponseError = (getApiFilesIdDownloadResponse400 | getApiFilesIdDownloadResponse401 | getApiFilesIdDownloadResponse404 | getApiFilesIdDownloadResponse500) & {
  headers: Headers;
};

export type getApiFilesIdDownloadResponse = (getApiFilesIdDownloadResponseSuccess | getApiFilesIdDownloadResponseError)

export const getGetApiFilesIdDownloadUrl = (id: string,) => {


  

  return `/api/files/${id}/download`
}

export const getApiFilesIdDownload = async (id: string, options?: RequestInit): Promise<getApiFilesIdDownloadResponse> => {
  
  return customFetch<getApiFilesIdDownloadResponse>(getGetApiFilesIdDownloadUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetApiFilesIdDownloadQueryKey = (id: string,) => {
    return [
    `/api/files/${id}/download`
    ] as const;
    }

    
export const getGetApiFilesIdDownloadQueryOptions = <TData = Awaited<ReturnType<typeof getApiFilesIdDownload>>, TError = Blob>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesIdDownload>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiFilesIdDownloadQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiFilesIdDownload>>> = ({ signal }) => getApiFilesIdDownload(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiFilesIdDownload>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiFilesIdDownloadQueryResult = NonNullable<Awaited<ReturnType<typeof getApiFilesIdDownload>>>
export type GetApiFilesIdDownloadQueryError = Blob


export function useGetApiFilesIdDownload<TData = Awaited<ReturnType<typeof getApiFilesIdDownload>>, TError = Blob>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesIdDownload>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiFilesIdDownload>>,
          TError,
          Awaited<ReturnType<typeof getApiFilesIdDownload>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiFilesIdDownload<TData = Awaited<ReturnType<typeof getApiFilesIdDownload>>, TError = Blob>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesIdDownload>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiFilesIdDownload>>,
          TError,
          Awaited<ReturnType<typeof getApiFilesIdDownload>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiFilesIdDownload<TData = Awaited<ReturnType<typeof getApiFilesIdDownload>>, TError = Blob>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesIdDownload>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Download a file
 */

export function useGetApiFilesIdDownload<TData = Awaited<ReturnType<typeof getApiFilesIdDownload>>, TError = Blob>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiFilesIdDownload>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiFilesIdDownloadQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * Authenticate a user and receive a JWT token
 * @summary User login
 */
export type postApiLoginResponse200 = {
  data: InternalHandlersAuthResponse
  status: 200
}

export type postApiLoginResponse400 = {
  data: InternalHandlersErrorResponse
  status: 400
}

export type postApiLoginResponse401 = {
  data: InternalHandlersErrorResponse
  status: 401
}

export type postApiLoginResponse500 = {
  data: InternalHandlersErrorResponse
  status: 500
}
    
export type postApiLoginResponseSuccess = (postApiLoginResponse200) & {
  headers: Headers;
};
export type postApiLoginResponseError = (postApiLoginResponse400 | postApiLoginResponse401 | postApiLoginResponse500) & {
  headers: Headers;
};

export type postApiLoginResponse = (postApiLoginResponseSuccess | postApiLoginResponseError)

export const getPostApiLoginUrl = () => {


  

  return `/api/login`
}

export const postApiLogin = async (internalHandlersLoginRequest: InternalHandlersLoginRequest, options?: RequestInit): Promise<postApiLoginResponse> => {
  
  return customFetch<postApiLoginResponse>(getPostApiLoginUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      internalHandlersLoginRequest,)
  }
);}




export const getPostApiLoginMutationOptions = <TError = InternalHandlersErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiLogin>>, TError,{data: InternalHandlersLoginRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postApiLogin>>, TError,{data: InternalHandlersLoginRequest}, TContext> => {

const mutationKey = ['postApiLogin'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiLogin>>, {data: InternalHandlersLoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiLogin(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiLoginMutationResult = NonNullable<Awaited<ReturnType<typeof postApiLogin>>>
    export type PostApiLoginMutationBody = InternalHandlersLoginRequest
    export type PostApiLoginMutationError = InternalHandlersErrorResponse

    /**
 * @summary User login
 */
export const usePostApiLogin = <TError = InternalHandlersErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiLogin>>, TError,{data: InternalHandlersLoginRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiLogin>>,
        TError,
        {data: InternalHandlersLoginRequest},
        TContext
      > => {
      return useMutation(getPostApiLoginMutationOptions(options), queryClient);
    }
